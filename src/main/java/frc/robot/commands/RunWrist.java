// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Command.

package frc.robot.commands;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.CommandBase;
import java.util.function.DoubleSupplier;

import frc.robot.RobotContainer;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import frc.robot.subsystems.ClawWrist;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class RunWrist extends CommandBase {
    DigitalInput wristEncoder = new DigitalInput(4);
    
    int wristTicks = 0;
    int minTick = 0;
    int maxTick = 60; //IDK this
    boolean gotTick = false;
    int heightIndex = 0;
    boolean toggleUpPressed = false;
    boolean toggleDownPressed = false;
    boolean goUp = false;
    boolean goDown = false;
    int[] heights = new int[]{0, 20, 40};

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
        private final ClawWrist m_clawWrist;
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS


    public RunWrist(ClawWrist subsystem) {


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

        m_clawWrist = subsystem;
        addRequirements(m_clawWrist);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called when the command is initially scheduled.
    @Override
    public void initialize() {
    }

    // Called every time the scheduler runs while the command is scheduled.
    @Override
    public void execute() {
        //1 pinion rotation = 174.9 armature rotations
        double speed = 0;
        //.getMotorOutputVoltage()
       
        boolean toggleUp = RobotContainer.getInstance().getauxController().getLeftTriggerAxis() > 0.1;
        boolean toggleDown = RobotContainer.getInstance().getauxController().getRightTriggerAxis() > 0.1;
        boolean up = RobotContainer.getInstance().getauxController().getLeftBumper();
        boolean down = RobotContainer.getInstance().getauxController().getRightBumper();

        if (toggleUp && !toggleUpPressed){
            goUp = true;
            toggleUpPressed = true;
        }
        if (!toggleUp){
            goUp = false;
            toggleUpPressed = false;
        }
        if (toggleDown && !toggleDownPressed){
            goDown = true;
            toggleDownPressed = true;
        }
        if (!toggleDown){
            goDown = false;
            toggleDownPressed = false;
        }

        if (!wristEncoder.get() && !gotTick){// false is a "tick"
            if (m_clawWrist.getWrist() < 0) {wristTicks--;}
            if (m_clawWrist.getWrist() > 0) {wristTicks++;}
            if(up){
                for(int i = 0; i < heights.length; i++){
                     heights[i] --;
                }
            }
            if(down){
                for(int i = 0; i < heights.length; i++){
                    heights[i]++;  
                }
            }
            gotTick = true;
        } else if(wristEncoder.get()){
            gotTick = false;
        }
        
        //height [0] is highest
        //height [1] is middle
        //height [2] is lowest
        //height [3] is always equal to the current height
        //assuming 45 ticks = 1 pinion rotation
        
        if(goUp && heightIndex != 0){
            goUp = false;
            heightIndex--;
        }
        if(goDown && heightIndex != 2){
            goDown = false;
            heightIndex++;
        }
        //-ticks is positive rotation
        if(up || down){
            if (up){m_clawWrist.manualWrist(-1);}
            if (down){m_clawWrist.manualWrist(1);}

        }else{
            runTo(heights[heightIndex], wristTicks);
        }
    
        

        //m_clawWrist.manualWrist(speed);
        SmartDashboard.putNumber("Wrist Ticks:",wristTicks);
        SmartDashboard.putNumber("height index", heightIndex);
        
      // m_clawWrist.runWrist(RobotContainer.getInstance().getauxController().getRawAxis(1)); //Fix axis
        
    }
    public void runTo(double targetTick, double currentTick){
        boolean down = false;
        boolean up = false;
        int speed = 0;
        if (currentTick < targetTick){
            down = true;
        }else if (currentTick > targetTick){
            up = true;
        }

        if(up ){//&& wristTicks > minTick){ 
            speed = -1;
        }
        if(down ){//&& wristTicks < maxTick){
            speed = 1;
        }
        m_clawWrist.manualWrist(speed);

    }
   

    // Called once the command ends or is interrupted.
    @Override
    public void end(boolean interrupted) {
        m_clawWrist.stop();
    }

    // Returns true when the command should end.
    @Override
    public boolean isFinished() {
        return false;
    }

    @Override
    public boolean runsWhenDisabled() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
        return false;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
    }
}
