// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Command.

package frc.robot.commands;
import edu.wpi.first.wpilibj2.command.CommandBase;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import frc.robot.RobotContainer;
import frc.robot.subsystems.NavX;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import frc.robot.subsystems.DriveTrain;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class HaloDrive extends CommandBase {
    NavX navx = new NavX();
    double ticks = 0;

    double currentSpeed = 0;
    double currentRotation = 0;

    boolean brake = false;
    boolean currentlyBraking = false;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
        private final DriveTrain m_driveTrain;
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS


    public HaloDrive(DriveTrain subsystem) {


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

        m_driveTrain = subsystem;
        addRequirements(m_driveTrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called when the command is initially scheduled.
    @Override
    public void initialize() {
    }

    // Called every time the scheduler runs while the command is scheduled.
    

    private double deadband(double n, double deadband){
        if (Math.abs(n) < deadband)
        {
            return 0;
        }
        return n;
    }



    public void drive() {
        navx.displayAxis();
/*
        if(RobotContainer.getInstance().getdriverController().getRawAxis(3) > 0.2){
            brake = true;
        }else{
            brake = false;
        }

        if(brake && !currentlyBraking){
            m_driveTrain.setBrakeMode();
            currentlyBraking = true;
        }

        if(!brake && currentlyBraking){
            m_driveTrain.setCoastMode();
            currentlyBraking = false;
        }
*/

/*


if(RobotContainer.getInstance().getdriverController().getRawAxis(3) > 0.2){
    m_driveTrain.setBrakeMode();
}
else{
    m_driveTrain.setCoastMode();
}
*/



    //directional pad adjustments
        int pov = RobotContainer.getInstance().getdriverController().getPOV();

        

        double finesse = 1;
        double leftSpeed = RobotContainer.getInstance().getdriverController().getRawAxis(1);
        double rightSpeed = RobotContainer.getInstance().getdriverController().getRawAxis(5);

        double rotation = RobotContainer.getInstance().getdriverController().getRawAxis(4);

        rotation = deadband(rotation, .1);

        rotation = Math.pow(rotation, 9);

/*      this is for tryin to do an arcade drive with tank drive method still
        if(rotation > 0){
            rightSpeed += rotation;
        }
        if(rotation < 0){
            leftSpeed += -1*rotation;
        }
*/
        //rotation *= 0.7;

        leftSpeed = deadband(leftSpeed, .2);
        rightSpeed = deadband(rightSpeed, 0.2);
        
        //XboxController m_hid = new XboxController(0);
        //m_hid.setRumble(GenericHID.RumbleType.kBothRumble, 1.0);
        
        

           

        // This will delinearize the driving
        int exponent = 9;
        rightSpeed = Math.pow(rightSpeed , exponent);
        leftSpeed = Math.pow(leftSpeed , exponent);

            
//right arrow turns right, left arrow turns left


if (RobotContainer.getInstance().getdriverController().getLeftTriggerAxis() > 0.2){finesse = .5;}  
        leftSpeed *= finesse;
        rightSpeed *= finesse;
       rotation *= finesse;

        

        //acceleration curve
        currentSpeed = exponentialAcceleration(currentSpeed, leftSpeed);
        
        leftSpeed = currentSpeed;
        rightSpeed = currentSpeed;

        //rotation = updateValues(currentRotation, rotation);

        
        
        double dpadSpeed = 0.62;
        dpadSpeed *= finesse;
        //right if the dpad (pov) is top left, middle left, or bottom left
        if(pov > 40  && pov < 140){
            m_driveTrain.driveTank(dpadSpeed, -dpadSpeed);
            leftSpeed = .3;
            rightSpeed = -.3;
            
            //left if the dpad (pov) is top right, middle right, or bottom right
        }else if(pov > 220 && pov < 275){
            m_driveTrain.driveTank(-dpadSpeed, dpadSpeed);

        }else if(pov > 275 || pov < 40 && pov != -1){
            m_driveTrain.driveTank(-dpadSpeed, -dpadSpeed);

        }else if(pov > 140 && pov < 220){
            m_driveTrain.driveTank(dpadSpeed, dpadSpeed);

        }
        else{

            m_driveTrain.driveArcade(currentSpeed, rotation);
        }






        //uncomment/comment based on if you want arcade drive or tank
        
       // m_driveTrain.driveTank(leftSpeed, rightSpeed);
       

    }   
    public void levelSelf()
    {
        navx.displayAxis();
        
        double pitch = (double)navx.getPitch();
        SmartDashboard.putNumber("pitch", pitch);


        double speed = (pitch)+0.083;
        SmartDashboard.putNumber("speed1", speed);



        m_driveTrain.driveTank(speed, speed);
    }

    private static double exponentialAcceleration(double input, double currentSpeed){
        if(input * currentSpeed < 0.0){
              input = 0.0;
          }
          
          
          
          if(input > 0.0 && currentSpeed > -0.1 && currentSpeed < 0.1){
             return 0.1;
          }
          
          if(input < 0.0 && currentSpeed > -0.1 && currentSpeed < 0.1){
             return -0.1;
          }
                System.out.println("diff: " + input + " - " + currentSpeed + " = " + (input-currentSpeed));
          double difference = input - currentSpeed;
    
          
          double change = Math.pow(difference, 2)/2;
    if(Math.abs(difference) < 0.05){
        return input;
    }
          
          if(input < currentSpeed){
              currentSpeed -=change;
          }
          if(input > currentSpeed){
              currentSpeed += change;
          }
          
          if(currentSpeed < -1){
              currentSpeed = -1;
          }
          if(currentSpeed > 1){
              currentSpeed = 1;
          }
          
          return currentSpeed;
        }

    private double linearAcceleration(double speed, double input){
       double acceleration = 0.01;
        double decceleration = 0.08;
     




       //+ needs to speed up, - needs to slow down
       double difference = input - speed;

 



        if((speed > -0.1 && speed < 0.1)){
            if(input == 0){
                return 0;
            }
            if(input > 0){
                return 0.1;
            }
            if(input < 0){
                return -0.1;
            }
        }

        if(input == 0){
            if(speed >= -decceleration && speed <= decceleration){
                return 0;
            }
            if(speed > 0){
                return speed - decceleration;
            }
            if(speed < 0){
                return speed + decceleration;
            }
        }

       //if difference is positive AND less than the acceleration, just makes it equal to the input
       if(difference > 0 && difference < acceleration){
        return input;
       }

       //if difference is negative AND greater than decceleration (-acceleration), just makes it equal to the input;
       if(difference < 0 && difference > -acceleration){
        return input;
       }
       
       //if it needs to speed up, speeds up by acceleration value
       if(difference > 0){
        return speed += acceleration;
       }

       //if it needs to slow down, slows down by acceleration value
       if(difference < 0){
        return speed -= acceleration;
       }
       
        //if no change is needed, don't change it
        return speed;
    }







    @Override
    public void execute() {
        drive();
        //ticks++;
        //SmartDashboard.putNumber("ticks", ticks);
      /* 
        SmartDashboard.putBoolean("self level activated", RobotContainer.getInstance().getdriverController().getRightBumper());
        if(RobotContainer.getInstance().getdriverController().getRightBumper())
        {
            levelSelf();
        }
        else{
            drive();
        }
            */
    
    }
            

            
    



    // Called once the command ends or is interrupted.
    @Override
    public void end(boolean interrupted) {
    }

    // Returns true when the command should end.
    @Override
    public boolean isFinished() {
        return false;
    }

    @Override
    public boolean runsWhenDisabled() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
        return false;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
    }
}
