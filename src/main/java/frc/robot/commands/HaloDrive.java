// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Command.

package frc.robot.commands;
import edu.wpi.first.wpilibj2.command.CommandBase;
import java.util.function.DoubleSupplier;
import edu.wpi.first.wpilibj.GenericHID;
import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import frc.robot.RobotContainer;
import frc.robot.subsystems.NavX;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import frc.robot.subsystems.DriveTrain;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class HaloDrive extends CommandBase {
    NavX navx = new NavX();

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
        private final DriveTrain m_driveTrain;
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS


    public HaloDrive(DriveTrain subsystem) {


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

        m_driveTrain = subsystem;
        addRequirements(m_driveTrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called when the command is initially scheduled.
    @Override
    public void initialize() {
    }

    // Called every time the scheduler runs while the command is scheduled.
    

    private double deadband(double n, double deadband){
        if (Math.abs(n) < deadband)
        {
            return 0;
        }
        return n;
    }



    public void drive() {

        SmartDashboard.putBoolean("driving", true);


    //directional pad adjustments
        SmartDashboard.putNumber("POV", RobotContainer.getInstance().getdriverController().getPOV());
        int pov = RobotContainer.getInstance().getdriverController().getPOV();

        

        double finesse = 1;
        double leftSpeed = RobotContainer.getInstance().getdriverController().getRawAxis(1);
        double rightSpeed = RobotContainer.getInstance().getdriverController().getRawAxis(5);

        double rotation = RobotContainer.getInstance().getdriverController().getRawAxis(4);

        rotation = deadband(rotation, .1);

        rotation = Math.pow(rotation, 9);

/*      this is for tryin to do an arcade drive with tank drive method still
        if(rotation > 0){
            rightSpeed += rotation;
        }
        if(rotation < 0){
            leftSpeed += -1*rotation;
        }
*/
        //rotation *= 0.7;

        leftSpeed = deadband(leftSpeed, .2);
        rightSpeed = deadband(rightSpeed, 0.2);
        
        //XboxController m_hid = new XboxController(0);
        //m_hid.setRumble(GenericHID.RumbleType.kBothRumble, 1.0);
            
        
            
        // This will delinearize the driving
        int exponent = 9;
        rightSpeed = Math.pow(rightSpeed , exponent);
        leftSpeed = Math.pow(leftSpeed , exponent);

        SmartDashboard.putNumber("left trigger", RobotContainer.getInstance().getdriverController().getLeftTriggerAxis());
            
//right arrow turns right, left arrow turns left


if (RobotContainer.getInstance().getdriverController().getLeftTriggerAxis() > 0.2){finesse = .5;}  
        leftSpeed *= finesse;
        rightSpeed *= finesse;
       // rotation *= finesse;     see if this works

        //right if the dpad (pov) is top left, middle left, or bottom left
        if(pov > 40  && pov < 140){
            leftSpeed = .3;
            rightSpeed = -.3;
            
            //left if the dpad (pov) is top right, middle right, or bottom right
        }else if(pov > 220 && pov < 275){
            leftSpeed = -.3;
            rightSpeed = .3;
        }else if(pov > 275 || pov < 40 && pov != -1){
            leftSpeed = .3;
            rightSpeed = .3;
        }else if(pov > 140 && pov < 220){
            leftSpeed = -.3;
            rightSpeed = -.3;
        }


        //uncomment/comment based on if you want arcade drive or tank
        
       // m_driveTrain.driveTank(leftSpeed, rightSpeed);
       m_driveTrain.driveArcade(leftSpeed, rotation);
    }   
    public void levelSelf()
    {
        navx.displayAxis();
        
        double pitch = (double)navx.getPitch();
        SmartDashboard.putNumber("pitch", pitch);


        double speed = (pitch/20)+0.083;
        SmartDashboard.putNumber("speed1", speed);


        SmartDashboard.putNumber("speed2", speed);


        m_driveTrain.driveTank(speed, speed);
    }

    @Override
    public void execute() {
        drive();
      /* 
        SmartDashboard.putBoolean("self level activated", RobotContainer.getInstance().getdriverController().getRightBumper());
        if(RobotContainer.getInstance().getdriverController().getRightBumper())
        {
            levelSelf();
        }
        else{
            drive();
        }
            */
    
    }
            

            
    



    // Called once the command ends or is interrupted.
    @Override
    public void end(boolean interrupted) {
    }

    // Returns true when the command should end.
    @Override
    public boolean isFinished() {
        return false;
    }

    @Override
    public boolean runsWhenDisabled() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
        return false;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
    }
}
